package main

import (
	"fmt"
	"io"
)

// The definitions in this file were generated by wire9
// and then modified by hand to use 32-bit aligned reads.
// Microsoft aligns their strings on a 32-bit boundary and
// pads them with "W+". The W particles are not included
// in the strings' sizes on the wire.

// ReadBinary marshals bytes read from r into a name. The
// read ends on a 32-bit boundary.
func (z *name) ReadBinary(r io.Reader) (err error) {
	if z == nil {
		return fmt.Errorf("ReadBinary: name nil")
	}

	if err = binread(r, LE, &z.group); err != nil {
		return
	}

	if err = binread(r, LE, &z.nextat); err != nil {
		return
	}

	if err = binread(r, LE, &z.n); err != nil {
		return
	}
	if err = binread(r, LE, &z.flag); err != nil {
		return
	}
	if err = binread(r, LE, &z.hash); err != nil {
		return
	}

	z.data = make([]byte, int(z.n))
	if n, err := r.Read(z.data); err != nil || n < int(z.n) {
		if err != nil {
			return err
		}
		return ioErr("z.data", "read", n, int(z.n))
	} else if n%4 != 0 {
		r.Read(make([]byte, 4-n%4))
	}
	return nil
}

// ReadBinary marshals bytes read from r into a bstring. The
// read ends on a 32-bit boundary.
func (z *bstr) ReadBinary(r io.Reader) (err error) {
	if z == nil {
		return fmt.Errorf("ReadBinary: bstring nil")
	}

	if err = binread(r, LE, &z.n); err != nil {
		return
	}

	z.data = make([]byte, int(z.n))
	if n, err := r.Read(z.data); err != nil || n < int(z.n) {
		if err != nil {
			return err
		}
		return ioErr("z.data", "read", n, int(z.n))
	} else if n = n + 2; n%4 != 0 {
		r.Read(make([]byte, 4-n%4))
	}

	return nil
}
